"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwtVerify = exports.protectRoute = exports.getUser = void 0;
const kinde_node_auth_utils_1 = __importDefault(require("@kinde-oss/kinde-node-auth-utils"));
const setup_1 = require("../setup");
const aws_jwt_verify_1 = require("aws-jwt-verify");
const { authToken, getPem } = kinde_node_auth_utils_1.default;
/**
 * Custom middleware fetches details for the authenticated user and attaches them
 * to the request object, available as `req.user` and having the following type
 * @type {UserType}.
 *
 * @param {Request}
 * @param {Response} res
 * @param {NextFunction} next
 * @returns {Promise<void>}
 */
const getUser = async (req, res, next) => {
    const kindeClient = (0, setup_1.getInternalClient)();
    if (!(await kindeClient.isAuthenticated(req))) {
        const logoutURL = await kindeClient.logout(req);
        return res.redirect(logoutURL.toString());
    }
    try {
        const userProfile = await kindeClient.getUserProfile(req);
        req.user = userProfile;
        return next();
    }
    catch (error) {
        return next(error);
    }
};
exports.getUser = getUser;
/**
 * Custom middleware determines if the user is authenticated or not if so proceeds
 * to next middleware otherwise redirects to `unAuthorisedUrl` with 403 staus.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {NextFunction} next
 * @returns {Promise<void>}
 */
const protectRoute = async (req, res, next) => {
    const kindeClient = (0, setup_1.getInternalClient)();
    if (!(await kindeClient.isAuthenticated(req))) {
        const logoutURL = await kindeClient.logout(req);
        return res.redirect(logoutURL.toString());
    }
    const callbackFn = (error) => {
        if (error)
            return res.sendStatus(403);
        next();
    };
    const config = (0, setup_1.getInitialConfig)();
    const pem = await getPem(config.issuerBaseUrl);
    const parsedToken = await kindeClient.getToken(req);
    authToken(parsedToken, pem, callbackFn);
};
exports.protectRoute = protectRoute;
/**
 * Custom JWT verifier as middleware, for verifying integrity of JWT bearer
 * tokens in authorization headers.
 *
 * @param {string} issuer - issuerBaseUrl
 * @param {Record<string, string>}
 * @returns {ExpressMiddleware<Promise<void>>}
 */
const jwtVerify = (issuer, options) => {
    const { audience } = options;
    const verifier = aws_jwt_verify_1.JwtRsaVerifier.create({
        issuer,
        audience: audience || null,
        jwksUri: `${issuer}/.well-known/jwks.json`,
    });
    return async (req, res, next) => {
        try {
            const authHeader = req.headers.authorization;
            const token = authHeader && authHeader.split(' ')[1];
            const payload = await verifier.verify(token);
            console.log('Token is valid');
            // @ts-expect-error, preserving this behaviour owing to backward compatibility.
            req.user = { id: payload.sub };
            next();
        }
        catch (err) {
            console.log('Token not valid!');
            console.log(err);
            return res.sendStatus(403);
        }
    };
};
exports.jwtVerify = jwtVerify;
